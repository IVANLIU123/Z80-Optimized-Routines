;You may use this amazing routine, just be sure to credit John Metcalf!


sqrtHL:
;Written by John Metcalf here http://www.retroprogramming.com/2017/07/a-fast-z80-integer-square-root.html
;With some comments from Zeda
; fast 16-bit integer square root
; 90 bytes, 345-384 cycles (average 365.5)



; v2 - 3 t-state optimization spotted by Russ McNulty

; call with hl = number to square root
; returns    a = square root
; corrupts  hl, de
sqrtHL:
  ld a,h
  ld de,0B0C0h
  add a,e
  jr c,sq7
  ld a,h
  ld d,0F0h
sq7:

; ----------

  add a,d
  jr nc,sq6
  res 5,d
  db 254      ;this starts the `cp *` instruction to eat the following `sub d`
sq6:
  sub d
  sra d

; ----------

  set 2,d
  add a,d
  jr nc,sq5
  res 3,d
  db 254      ;this starts the `cp *` instruction to eat the following `sub d`
sq5:
  sub d
  sra d

; ----------

  inc d
  add a,d
  jr nc,sq4
  res 1,d
  db 254      ;this starts the `cp *` instruction to eat the following `sub d`
sq4:
  sub d
  sra d
  ld h,a

;With this iteration, we start working on E and can pretty much ignore D
; ----------

  xor a
  add hl,de
  jr c,sq3
  sbc hl,de
sq3:
  rra
  add a,e
  sra d
  rra

; ----------

  or 010h
  ld e,a
  add hl,de
  jr nc,sq2
  and 0DFh
  db 218      ;This starts the `jp c,**` instruction. Note that the previous `and` resets the carry flag
sq2:
  sbc hl,de
  sra d
  rra

; ----------

  or 04h
  ld e,a
  add hl,de
  jr nc,sq1
  and 0F7h
  db 218      ;This starts the `jp c,**` instruction. See comment above.
sq1:
  sbc hl,de
  sra d
  rra

; ----------

  ld e,a
  inc e
  add hl,de
  sbc a,0
  sra d
  rra
  cpl
  ret
